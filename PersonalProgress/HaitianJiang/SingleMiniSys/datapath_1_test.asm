nop
add $1,$2,$3	# $1 = 2 + 3 = 5
addu $2,$4,$1	# $2 = 4 + 5 = 9
sub $4,$2,$1	# $4 = 9 - 5 = 4
subu $5,$4,$3	# $5 = 4 - 3 = 1

and $6,$7,$8	# $6 = 0111 and 1000 = 0
or $7,$6,$8		# $7 = 0 or 1000 = 8
xor $7,$6,$8	# $7 = 0000 xor 1000 = 1000 = 8
nor $8,$7,$6	# $8 = not (1000 or 0) = 11111111111110111

slt $10,$11,$12	# $10 = 11 < 12 = 1		# 应该用负数验证，以后再说
sltu $10,$12,$11	# $10 = 12 > 11 = 0

# sllv $12,$5,$13	# $12 = 1101 << 1 = 1101_0 = 1A	【注意此处的倒置问题！ sllv rd,rt,rs】
# srlv $12,$5,$13	# $12 = 1101 >> 1 = 110 = 6
# srav $14,$5,$15	# $14 = 1111 >>> 1 = 111  = 7 应该用负数验证，以后再说

# 上面3条是错误的！我们应该改的不是使用，而是内部运算逻辑
# 对于使用者来说，逻辑就是 $13 << $5
# 而实际的编码是 rt = $13，rs = $5，这与一般的指令不一样
# 因此，我们在ALU运算中 rt--B，rs--A，应该是 【B << A】，而不是 A >> B。
sllv $12,$13,$5	# $12 = 1101 << 1 = 1101_0 = 1A	
srlv $12,$13,$5	# $12 = 1101 >> 1 = 110 = 6
srav $14,$15,$5	# $14 = 1111 >>> 1 = 111  = 7 应该用负数验证，以后再说

sll $16,$17,2	# $16 = 1_0001 << 2 = 100_0100 = 44	
srl $16,$18,2	# $16 = 1_0010 >> 2 = 0100 = 4
sra $16,$19,2	# 应该用负数验证，以后再说 $16 = 4

jr $16	# PC = 4

